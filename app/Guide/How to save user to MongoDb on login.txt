Since you're using the App Router in your Next.js project with TypeScript, the approach will be slightly different because App Router leverages server components and React's new paradigms, instead of the classic pages-based routing system.

Adjusting to the App Router
I'll guide you through the recommended steps to handle user session management and database storage directly using the App Router:

Step-by-Step Guide (App Router)
1. Middleware Setup for Session Management
First, you'll still want to use middleware to intercept incoming requests and check the user session.

Create a middleware in the root middleware.ts file:

typescript
Copy code
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { getSession } from "./lib/session"; // Adjust the path as needed
import { saveUserDataToDatabase } from "./lib/database"; // Adjust the path as needed

export async function middleware(req: NextRequest) {
  const session = await getSession(req);

  // If session is present and user data is available, save to database
  if (session?.user) {
    try {
      await saveUserDataToDatabase(session.user);
    } catch (error) {
      console.error("Error saving user data to the database:", error);
    }
  }

  return NextResponse.next();
}

// Apply middleware to specific routes
export const config = {
  matcher: ["/home", "/dashboard"], // Routes where middleware applies
};
2. Session and Database Utilities (Server Components)
Create a session utility in lib/session.ts:
This file will handle retrieving the user session, especially if you're using JWT or cookies.

typescript
Copy code
// lib/session.ts
import { cookies } from "next/headers";
import { decodeJwt } from "some-jwt-library"; // Use your preferred library
import { GoogleUser } from "@/types/user";

export async function getSession(req: NextRequest): Promise<{ user: GoogleUser } | null> {
  const cookieStore = cookies();
  const token = cookieStore.get("your-session-cookie");

  if (token) {
    try {
      // Decode JWT and return user information
      const decoded = decodeJwt(token.value); // Adjust decoding based on your setup
      return { user: decoded as GoogleUser };
    } catch (error) {
      console.error("Error decoding session token:", error);
    }
  }

  return null; // Return null if no valid session
}
Database Utility in lib/database.ts:
A file for handling database operations with MongoDB:

typescript
Copy code
// lib/database.ts
import { MongoClient } from "mongodb";
import { GoogleUser } from "@/types/user";

// MongoDB connection setup
const client = new MongoClient(process.env.MONGODB_URI || "");
const database = client.db("your-database-name");
const usersCollection = database.collection("users");

export async function saveUserDataToDatabase(user: GoogleUser) {
  try {
    await client.connect();

    // Check if user already exists
    const existingUser = await usersCollection.findOne({ email: user.email });

    if (!existingUser) {
      // Insert new user
      await usersCollection.insertOne(user);
    } else {
      // Update existing user data
      await usersCollection.updateOne(
        { email: user.email },
        { $set: user }
      );
    }
  } finally {
    await client.close();
  }
}
3. Loading Session Data in Server Components
With the App Router, server components are ideal for handling session-related actions. Here’s how you might render the home page using server components to check the user’s session:

Home Component in app/home/page.tsx:
typescript
Copy code
// app/home/page.tsx
import { getSession } from "@/lib/session";
import { redirect } from "next/navigation";

// This is a server component
export default async function HomePage() {
  // Fetch session data (this function runs on the server)
  const session = await getSession();

  if (!session?.user) {
    // If not authenticated, redirect to login
    redirect("/login");
  }

  // If user is authenticated, you can safely render user data
  return (
    <div>
      <h1>Welcome, {session.user.name}</h1>
      <p>Email: {session.user.email}</p>
      {/* Render additional user data or page components */}
    </div>
  );
}
4. API Route for Handling Google Sign-In (API Directory)
With the App Router, you still have the ability to define server functions to handle API routes for authentication:

Create the Google Sign-In API in app/api/auth/google/route.ts:
typescript
Copy code
// app/api/auth/google/route.ts
import { NextRequest, NextResponse } from "next/server";
import { validateUserData } from "@/lib/validation";
import { handleGoogleSignIn } from "@/lib/handler";
import { GoogleUser } from "@/types/user";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const validatedUser: GoogleUser = validateUserData(body.user);

    // Process the user sign-in data
    const processedUser = await handleGoogleSignIn(validatedUser);

    // Return the response to the client
    return NextResponse.json({ user: processedUser });
  } catch (error: any) {
    console.error("Error processing user data:", error);
    return NextResponse.json(
      { error: error.message || "Internal Server Error" },
      { status: error.status || 500 }
    );
  }
}
Best Practices Summary for App Router
Use middleware to manage session checking and data-saving globally.
Keep server functions and database interactions in utility files for modularity.
Leverage server components to handle authentication checks and rendering user-specific data directly on the server.
Use API routes in the app/api directory for handling specific actions like Google Sign-In.
This structure aligns with Next.js's App Router and best practices for server-rendered, authenticated applications.