In Next.js 13 and beyond, the App Router (app directory) approach introduces a modern way to manage routes and APIs while maintaining type safety with TypeScript. Here's how you can implement Google Sign-In with MongoDB using the App Router:

1. Directory Structure
Ensure your Next.js app directory follows this structure:

arduino
Copy code
app/
├── api/
│   └── auth/
│       └── route.ts  // API route for handling Google Sign-In
├── layout.tsx
├── page.tsx
lib/
├── mongodb.ts        // MongoDB connection utility
utils/
├── handleUserData.ts // User data processing logic
types/
├── user.ts           // TypeScript type definitions
.env.local            // Environment variables
2. MongoDB Connection
Create a utility file to manage MongoDB connections.

lib/mongodb.ts
typescript
Copy code
import { MongoClient } from "mongodb";

const uri = process.env.MONGODB_URI as string; // Ensure this exists in .env.local
const options = {};

let client: MongoClient;
let clientPromise: Promise<MongoClient>;

if (!uri) {
  throw new Error("Please add your MongoDB URI to .env.local");
}

if (process.env.NODE_ENV === "development") {
  // Reuse the client in development to avoid multiple connections
  if (!(global as any)._mongoClientPromise) {
    client = new MongoClient(uri, options);
    (global as any)._mongoClientPromise = client.connect();
  }
  clientPromise = (global as any)._mongoClientPromise;
} else {
  // In production, always create a new client
  client = new MongoClient(uri, options);
  clientPromise = client.connect();
}

export default clientPromise;
3. Define TypeScript Types
Create a User type to structure user data.

types/user.ts
typescript
Copy code
export interface User {
  name: string;
  email: string;
  image: string;
  createdAt: Date;
  lastLogin: Date;
}
4. User Data Handling Logic
Add a utility function to process and store user data.

utils/handleUserData.ts
typescript
Copy code
import clientPromise from "../lib/mongodb";
import { User } from "../types/user";

export async function handleUserData(user: {
  email: string;
  name: string;
  picture: string;
}): Promise<User> {
  const client = await clientPromise;
  const db = client.db("myDatabase");
  const usersCollection = db.collection<User>("users");

  const { email, name, picture } = user;

  const existingUser = await usersCollection.findOne({ email });

  if (existingUser) {
    // Update last login timestamp
    await usersCollection.updateOne(
      { email },
      { $set: { lastLogin: new Date() } }
    );
    return existingUser;
  }

  // Insert a new user
  const newUser: User = {
    name,
    email,
    image: picture,
    createdAt: new Date(),
    lastLogin: new Date(),
  };

  await usersCollection.insertOne(newUser);
  return newUser;
}
5. Google Sign-In API Route
Define the API route using the App Router's route.ts.

app/api/auth/route.ts
typescript
Copy code
import { NextRequest, NextResponse } from "next/server";
import { handleUserData } from "../../../utils/handleUserData";
import { z } from "zod";

// Define user schema for validation
const UserSchema = z.object({
  email: z.string().email(),
  name: z.string(),
  picture: z.string().url(),
});

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const validatedUser = UserSchema.parse(body.user); // Validate input

    const processedUser = await handleUserData(validatedUser);

    return NextResponse.json({ user: processedUser });
  } catch (error) {
    console.error("Error processing user data:", error);
    return NextResponse.json(
      { error: "Failed to process user data" },
      { status: 500 }
    );
  }
}
6. Environment Variables
Add your environment variables in .env.local:

env
Copy code
MONGODB_URI=mongodb+srv://<username>:<password>@cluster.mongodb.net/myDatabase?retryWrites=true&w=majority
7. Using the API in the Client
From your client-side code (e.g., a Sign-In button), send user data to the API route after successful Google Sign-In.

Example Client Component
typescript
Copy code
"use client";

import { signIn } from "next-auth/react";

export default function GoogleSignInButton() {
  const handleGoogleSignIn = async () => {
    try {
      const response = await signIn("google", { redirect: false });
      const user = response?.user;

      if (user) {
        // Send user data to the API
        const res = await fetch("/api/auth", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ user }),
        });

        const data = await res.json();
        console.log("User data processed:", data);
      }
    } catch (error) {
      console.error("Google Sign-In error:", error);
    }
  };

  return <button onClick={handleGoogleSignIn}>Sign in with Google</button>;
}
8. Key Best Practices
Type Safety

Use TypeScript for all utilities, API routes, and client components.
Validate data with zod to avoid runtime errors.
Secure MongoDB

Use environment variables for sensitive credentials.
Enable IP whitelisting and TLS/SSL for MongoDB connections.
Optimize MongoDB Queries

Create indexes on frequently queried fields (e.g., email):
typescript
Copy code
await db.collection("users").createIndex({ email: 1 }, { unique: true });
Error Handling

Use try-catch blocks for all async operations and return meaningful error messages.
9. Example Workflow
User clicks Sign in with Google.
Google returns user data.
The client sends the user data to /api/auth via a POST request.
The API route processes the user data:
Checks if the user exists in MongoDB.
Updates the lastLogin timestamp for existing users.
Inserts new users into the database.
Processed user data is returned to the client.
This approach ensures modern, secure, and scalable handling of Google Sign-In with the Next.js App Router and MongoDB. Let me know if you need further clarification!